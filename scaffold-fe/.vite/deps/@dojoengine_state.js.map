{
  "version": 3,
  "sources": ["../../node_modules/@dojoengine/state/src/recs/index.ts", "../../node_modules/@dojoengine/state/src/utils/index.ts"],
  "sourcesContent": ["import {\n    Component,\n    ComponentValue,\n    Entity,\n    Metadata,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport {\n    Clause,\n    ToriiClient,\n    EntityKeysClause,\n    PatternMatching,\n} from \"@dojoengine/torii-client\";\nimport { convertValues } from \"../utils\";\n\n/**\n * Fetches and synchronizes entities with their components. This is useful for initializing the world state.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An array of entities to synchronize.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n * @returns A promise that resolves when synchronization is complete.\n *\n * @example\n * // Fetch all entities and their components\n * const components = createClientComponents({ contractComponents });\n * await getSyncEntities(client, components, undefined);\n *\n * @example\n * // Fetch all entities and their components via a query\n * const components = createClientComponents({ contractComponents });\n * await getSyncEntities(client, components, entityKeyClause);\n *\n * This function fetches all entities and their components from the client, then\n * synchronizes the entities with the specified components. It uses the provided\n * EntityKeysClause (if any) to filter entities and the specified components to\n * determine which data to retrieve. The function continues fetching until all\n * matching entities have been retrieved, using the 'limit' parameter to control\n * the batch size of each request.\n */\nexport const getSyncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[],\n    limit: number = 100\n) => {\n    await getEntities(client, components, limit);\n    return await syncEntities(client, components, entityKeyClause);\n};\n\n/**\n * Fetches and synchronizes events with their models. This is useful for initializing the world state with event data.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param clause - An optional clause to filter events.\n * @param entityKeyClause - An array of entities to synchronize.\n * @param limit - The maximum number of events to fetch per request (default: 100).\n * @returns A promise that resolves when synchronization is complete.\n *\n * @example\n * // Fetch all events and their components\n * const components = createClientComponents({ contractComponents });\n * await getSyncEvents(client, components, undefined, entityKeyClause);\n *\n * @example\n * // Fetch all events and their components via a query\n * const components = createClientComponents({ contractComponents });\n * await getSyncEvents(client, components, clause, entityKeyClause);\n *\n * This function fetches all events and their components from the client, then\n * synchronizes the events with the specified components. It uses the provided\n * Clause (if any) to filter events and the specified components to determine\n * which data to retrieve. The function continues fetching until all matching\n * events have been retrieved, using the 'limit' parameter to control the batch\n * size of each request.\n */\nexport const getSyncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    clause: Clause | undefined,\n    entityKeyClause: EntityKeysClause[],\n    limit: number = 100\n) => {\n    // Fetch events from the client\n    await getEvents(client, components, limit, clause);\n    // Synchronize the fetched events with the specified components\n    return await syncEvents(client, components, entityKeyClause);\n};\n\n/**\n * Fetches all entities and their components from the client.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of entities to fetch per request (default: 100).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntities(client, components, 100);\n *\n * This function performs paginated queries to fetch all entities and their components.\n */\nexport const getEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    limit: number = 100\n) => {\n    let cursor = 0;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const entities = await client.getAllEntities(limit, cursor);\n\n        setEntities(entities, components);\n\n        if (Object.keys(entities).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor += limit;\n        }\n    }\n};\n\n/**\n * Fetches event messages from the client and synchronizes them with the specified components.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param limit - The maximum number of event messages to fetch per request (default: 100).\n * @param clause - An optional clause to filter event messages.\n */\nexport const getEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    limit: number = 100,\n    clause: Clause | undefined\n) => {\n    let offset = 0; // Initialize the offset for pagination\n    let continueFetching = true; // Flag to control the fetching loop\n\n    while (continueFetching) {\n        // Fetch event messages from the client with the specified limit and offset\n        const entities = await client.getEventMessages({\n            limit,\n            offset,\n            clause,\n        });\n\n        console.log(\"entities\", entities); // Log the fetched entities for debugging\n\n        // Synchronize the fetched entities with the specified components\n        setEntities(entities, components);\n\n        // Check if the number of fetched entities is less than the limit\n        if (Object.keys(entities).length < limit) {\n            continueFetching = false; // Stop fetching if fewer entities are returned\n        } else {\n            offset += limit; // Increment the offset for the next batch\n        }\n    }\n};\n\n/**\n * Fetches entities and their components from the client based on specified criteria.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions to fetch.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities by their keys.\n * @param patternMatching - The pattern matching strategy for entity keys (default: \"FixedLen\").\n * @param limit - The maximum number of entities to fetch per request (default: 1000).\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, undefined, \"FixedLen\", 1000);\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, { Keys: { keys: [\"0x1\"], models: [\"Position\"] } }, \"FixedLen\", 1000);\n *\n * @example\n * const components = createClientComponents({ contractComponents });\n * await getEntitiesQuery(client, components, { HashedKeys: [\"0x1\"] }, \"FixedLen\", 1000);\n *\n * This function performs paginated queries to fetch all matching entities and their\n * components. It uses the provided EntityKeysClause (if any) to filter entities and\n * the specified components to determine which data to retrieve. The function continues\n * fetching until all matching entities have been retrieved, using the 'limit' parameter\n * to control the batch size of each request.\n */\nexport const getEntitiesQuery = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause,\n    patternMatching: PatternMatching = \"FixedLen\",\n    limit: number = 1000\n) => {\n    let cursor = 0;\n    let continueFetching = true;\n\n    while (continueFetching) {\n        const clause: Clause | null = entityKeyClause\n            ? {\n                  Keys: {\n                      keys:\n                          \"HashedKeys\" in entityKeyClause\n                              ? entityKeyClause.HashedKeys\n                              : entityKeyClause.Keys.keys,\n                      pattern_matching: patternMatching,\n                      models: [\n                          ...components.map((c) => c.metadata?.name as string),\n                      ],\n                  },\n              }\n            : null;\n\n        const fetchedEntities = await client.getEntities({\n            limit,\n            offset: cursor,\n            clause: clause || undefined,\n        });\n\n        setEntities(fetchedEntities, components);\n\n        if (Object.keys(fetchedEntities).length < limit) {\n            continueFetching = false;\n        } else {\n            cursor += limit;\n        }\n    }\n};\n\n/**\n * Sets up a subscription to sync entity updates.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities.\n * @returns A promise that resolves with the subscription handler.\n * The handler can be used to cancel the subscription when needed.\n * @example\n * const sync = await getSyncEntities(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEntities = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[]\n) => {\n    return await client.onEntityUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            setEntities({ [fetchedEntities]: data }, components);\n        }\n    );\n};\n\n/**\n * Sets up a subscription to sync event messages.\n * @param client - The client instance for API communication.\n * @param components - An array of component definitions.\n * @param entityKeyClause - An optional EntityKeysClause to filter entities.\n * @returns A promise that resolves with the subscription handler.\n * The handler can be used to cancel the subscription when needed.\n * @example\n * const sync = await syncEvents(client, components, entityKeyClause);\n * // later...\n * sync.cancel(); // cancel the subscription\n */\nexport const syncEvents = async <S extends Schema>(\n    client: ToriiClient,\n    components: Component<S, Metadata, undefined>[],\n    entityKeyClause: EntityKeysClause[]\n) => {\n    return await client.onEventMessageUpdated(\n        entityKeyClause,\n        (fetchedEntities: any, data: any) => {\n            // Log the fetched entities and data for debugging purposes\n            console.log(\"fetchedEntities\", data);\n            // Update the local state with the fetched entities and their data\n            setEntities({ [fetchedEntities]: data }, components);\n        }\n    );\n};\n\n/**\n * Updates the components of entities in the local state.\n * @param entities - An array of entities with their updated component data.\n * @param components - An array of component definitions.\n */\nexport const setEntities = async <S extends Schema>(\n    entities: any,\n    components: Component<S, Metadata, undefined>[]\n) => {\n    for (let key in entities) {\n        if (!Object.hasOwn(entities, key)) {\n            continue;\n        }\n\n        for (let componentName in entities[key]) {\n            if (!Object.hasOwn(entities[key], componentName)) {\n                continue;\n            }\n            let recsComponent = Object.values(components).find(\n                (component) =>\n                    component.metadata?.namespace +\n                        \"-\" +\n                        component.metadata?.name ===\n                    componentName\n            );\n\n            if (recsComponent) {\n                try {\n                    setComponent(\n                        recsComponent,\n                        key as Entity,\n                        convertValues(\n                            recsComponent.schema,\n                            entities[key][componentName]\n                        ) as ComponentValue\n                    );\n                } catch (error) {\n                    console.warn(\n                        `Failed to set component ${recsComponent.metadata?.name} on ${key}`,\n                        error\n                    );\n                }\n            }\n        }\n    }\n};\n", "import { Type as RecsType, Schema } from \"@dojoengine/recs\";\n\nexport function convertValues(schema: Schema, values: any) {\n    return Object.keys(schema).reduce<any>((acc, key) => {\n        if (!acc) {\n            acc = {};\n        }\n        const schemaType = schema[key];\n        const value = values[key];\n\n        if (value === null || value === undefined) {\n            acc[key] = value;\n            return acc;\n        }\n\n        if (value.type === \"enum\") {\n            acc[key] = value.value.option;\n            return acc;\n        }\n\n        switch (schemaType) {\n            case RecsType.StringArray:\n                if (value.type === \"array\" && value.value[0].type === \"enum\") {\n                    acc[key] = value.value.map(\n                        (item: any) => item.value.option\n                    );\n                } else {\n                    acc[key] = value.value.map((a: any) => {\n                        try {\n                            return BigInt(a.value);\n                        } catch (error) {\n                            console.warn(\n                                `Failed to convert ${a.value} to BigInt. Using string value instead.`\n                            );\n                            return a.value;\n                        }\n                    });\n                }\n                break;\n\n            case RecsType.String:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.BigInt:\n                try {\n                    acc[key] = BigInt(value.value);\n                } catch (error) {\n                    console.warn(\n                        `Failed to convert ${value.value} to BigInt. Using string value instead.`\n                    );\n\n                    acc[key] = BigInt(`0x${value.value}`);\n                }\n                break;\n\n            case RecsType.Boolean:\n                acc[key] = value.value;\n                break;\n\n            case RecsType.Number:\n                acc[key] = Number(value.value);\n                break;\n\n            default:\n                if (typeof schemaType === \"object\" && value.type === \"struct\") {\n                    if (value.value instanceof Map) {\n                        const structValues = Object.fromEntries(value.value);\n                        acc[key] = convertValues(schemaType, structValues);\n                    } else {\n                        acc[key] = convertValues(schemaType, value.value);\n                    }\n                } else if (\n                    Array.isArray(schemaType) &&\n                    value.type === \"array\"\n                ) {\n                    acc[key] = value.value.map((item: any) =>\n                        convertValues(schemaType[0], item)\n                    );\n                } else {\n                    acc[key] = value.value;\n                }\n                break;\n        }\n\n        return acc;\n    }, {});\n}\n"],
  "mappings": "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",
  "names": ["convertValues", "schema", "values", "acc", "key", "schemaType", "value", "RecsType", "item", "a", "structValues", "getSyncEntities", "client", "components", "entityKeyClause", "limit", "getEntities", "syncEntities", "getSyncEvents", "clause", "getEvents", "syncEvents", "cursor", "continueFetching", "entities", "setEntities", "offset", "getEntitiesQuery", "patternMatching", "c", "fetchedEntities", "data", "componentName", "recsComponent", "component", "_a", "setComponent", "error"]
}
